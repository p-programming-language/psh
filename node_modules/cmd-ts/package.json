{
  "name": "cmd-ts",
  "version": "0.13.0",
  "homepage": "https://cmd-ts.now.sh",
  "license": "MIT",
  "author": "Gal Schlezinger",
  "main": "dist/cjs/index.js",
  "typings": "dist/cjs/index.d.ts",
  "module": "dist/esm/index.js",
  "files": [
    "dist",
    "batteries"
  ],
  "husky": {
    "hooks": {
      "pre-commit": "yarn lint"
    }
  },
  "sideEffects": false,
  "prettier": {
    "printWidth": 80,
    "semi": true,
    "singleQuote": true,
    "trailingComma": "es5"
  },
  "dependencies": {
    "chalk": "^4.0.0",
    "debug": "^4.3.4",
    "didyoumean": "^1.2.2",
    "strip-ansi": "^6.0.0"
  },
  "devDependencies": {
    "@changesets/cli": "2.23.2",
    "@swc-node/register": "1.5.1",
    "@types/debug": "4.1.7",
    "@types/didyoumean": "1.2.0",
    "@types/fs-extra": "9.0.13",
    "@types/node-fetch": "2.6.2",
    "@types/request": "2.48.8",
    "@typescript-eslint/eslint-plugin": "5.30.7",
    "@typescript-eslint/parser": "5.30.7",
    "cargo-mdbook": "0.4.4",
    "docs-ts": "0.6.10",
    "eslint": "8.20.0",
    "eslint-config-prettier": "8.5.0",
    "eslint-plugin-import": "2.26.0",
    "eslint-plugin-prettier": "4.2.1",
    "esm": "3.2.25",
    "execa": "6.1.0",
    "fs-extra": "10.1.0",
    "husky": "8.0.1",
    "infer-types": "0.0.2",
    "node-fetch": "2.6.7",
    "prettier": "2.7.1",
    "request": "2.88.2",
    "tempy": "3.0.0",
    "typedoc": "0.23.8",
    "typescript": "4.7.4",
    "vitest": "0.18.1"
  },
  "scripts": {
    "build": "tsc && tsc --project ./tsconfig.esm.json",
    "lint": "eslint src/**/*.ts test/**/*.ts example/**/*.ts ./.eslintrc.js",
    "now-build": "mdbook build --dest-dir=public",
    "start": "yarn build --watch",
    "test": "vitest",
    "ts-node": "./scripts/ts-node",
    "changeset:version": "changeset version && pnpm install --no-frozen-lockfile",
    "changeset:publish": "pnpm run build && changeset publish"
  },
  "readme": "# `cmd-ts`\n\n> ðŸ’» A type-driven command line argument parser, with awesome error reporting ðŸ¤¤\n\nNot all command line arguments are strings, but for some reason, our CLI parsers force us to use strings everywhere. ðŸ¤” `cmd-ts` is a fully-fledged command line argument parser, influenced by Rust's [`clap`](https://github.com/clap-rs/clap) and [`structopt`](https://github.com/TeXitoi/structopt):\n\nðŸ¤© Awesome autocomplete, awesome safeness\n\nðŸŽ­ Decode your own custom types from strings with logic and context-aware error handling\n\nðŸŒ² Nested subcommands, composable API\n\n### Basic usage\n\n```ts\nimport { command, run, string, number, positional, option } from 'cmd-ts';\n\nconst cmd = command({\n  name: 'my-command',\n  description: 'print something to the screen',\n  version: '1.0.0',\n  args: {\n    number: positional({ type: number, displayName: 'num' }),\n    message: option({\n      long: 'greeting',\n      type: string,\n    }),\n  },\n  handler: (args) => {\n    args.message; // string\n    args.number; // number\n    console.log(args);\n  },\n});\n\nrun(cmd, process.argv.slice(2));\n```\n\n#### `command(arguments)`\n\nCreates a CLI command.\n\n### Decoding custom types from strings\n\nNot all command line arguments are strings. You sometimes want integers, UUIDs, file paths, directories, globs...\n\n> **Note:** this section describes the `ReadStream` type, implemented in `./src/example/test-types.ts`\n\nLet's say we're about to write a `cat` clone. We want to accept a file to read into stdout. A simple example would be something like:\n\n```ts\n// my-app.ts\n\nimport { command, run, positional, string } from 'cmd-ts';\n\nconst app = command({\n  /// name: ...,\n  args: {\n    file: positional({ type: string, displayName: 'file' }),\n  },\n  handler: ({ file }) => {\n    // read the file to the screen\n    fs.createReadStream(file).pipe(stdout);\n  },\n});\n\n// parse arguments\nrun(app, process.argv.slice(2));\n```\n\nThat works okay. But we can do better. In which ways?\n\n- Error handling is out of the command line argument parser context, and in userland, making things less consistent and pretty.\n- It shows we lack composability and encapsulation â€” and we miss a way to distribute shared \"command line\" behavior.\n\nWhat if we had a way to get a `Stream` out of the parser, instead of a plain string? This is where `cmd-ts` gets its power from, custom type decoding:\n\n```ts\n// ReadStream.ts\n\nimport { Type } from 'cmd-ts';\nimport fs from 'fs';\n\n// Type<string, Stream> reads as \"A type from `string` to `Stream`\"\nconst ReadStream: Type<string, Stream> = {\n  async from(str) {\n    if (!fs.existsSync(str)) {\n      // Here is our error handling!\n      throw new Error('File not found');\n    }\n\n    return fs.createReadStream(str);\n  },\n};\n```\n\nNow we can use (and share) this type and always get a `Stream`, instead of carrying the implementation detail around:\n\n```ts\n// my-app.ts\n\nimport { command, run, positional } from 'cmd-ts';\n\nconst app = command({\n  // name: ...,\n  args: {\n    stream: positional({ type: ReadStream, displayName: 'file' }),\n  },\n  handler: ({ stream }) => stream.pipe(process.stdout),\n});\n\n// parse arguments\nrun(app, process.argv.slice(2));\n```\n\nEncapsulating runtime behaviour and safe type conversions can help us with awesome user experience:\n\n- We can throw an error when the file is not found\n- We can try to parse the string as a URI and check if the protocol is HTTP, if so - make an HTTP request and return the body stream\n- We can see if the string is `-`, and when it happens, return `process.stdin` like many Unix applications\n\nAnd the best thing about it â€” everything is encapsulated to an easily tested type definition, which can be easily shared and reused. Take a look at [io-ts-types](https://github.com/gcanti/io-ts-types), for instance, which has types like DateFromISOString, NumberFromString and more, which is something we can totally do.\n\n## Inspiration\n\nThis project was previously called `clio-ts`, because it was based on `io-ts`. This is no longer the case, because I want to reduce the dependency count and mental overhead. I might have a function to migrate types between the two.\n"
}